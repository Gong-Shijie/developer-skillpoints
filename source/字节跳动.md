| 公司   | 岗位  | 题目                     | 次数 |
|------|-----|------------------------|----|
| 字节跳动 | 客户端 | [53\. 最大子序和]             | 7  |
| 字节跳动 | 客户端 | 215\. 数组中的第K个最大元素      | 6  |
| 字节跳动 | 客户端 | 236\. 二叉树的最近公共祖先       | 6  |
| 字节跳动 | 客户端 | 206\. 反转链表             | 6  |
| 字节跳动 | 客户端 | 21\. 合并两个有序链表          | 6  |
| 字节跳动 | 客户端 | 25\. K 个一组翻转链表         | 5  |
| 字节跳动 | 客户端 | 剑指 Offer 09\. 用两个栈实现队列 | 5  |
| 字节跳动 | 客户端 | 146\. LRU缓存机制          | 5  |
| 字节跳动 | 客户端 | 144\. 二叉树的前序遍历         | 4  |
| 字节跳动 | 客户端 | 344\. 反转字符串            | 4  |
| 字节跳动 | 客户端 | 543\. 二叉树的直径           | 4  |
| 字节跳动 | 客户端 | 160\. 相交链表             | 4  |
| 字节跳动 | 客户端 | 142\. 环形链表 II          | 3  |
| 字节跳动 | 客户端 | 104\. 二叉树的最大深度         | 3  |
| 字节跳动 | 客户端 | 394\. 字符串解码            | 3  |
| 字节跳动 | 客户端 | 145\. 二叉树的后序遍历         | 3  |
| 字节跳动 | 客户端 | 102\. 二叉树的层序遍历         | 3  |
| 字节跳动 | 客户端 | 3\. 无重复字符的最长子串         | 3  |
| 字节跳动 | 客户端 | 151\. 翻转字符串里的单词        | 3  |
| 字节跳动 | 客户端 | 958\. 二叉树的完全性检验        | 3  |
| 字节跳动 | 客户端 | 1\. 两数之和               | 3  |
| 字节跳动 | 客户端 | 94\. 二叉树的中序遍历          | 2  |
| 字节跳动 | 客户端 | 240\. 搜索二维矩阵 II        | 2  |
| 字节跳动 | 客户端 | 33\. 搜索旋转排序数组          | 2  |
| 字节跳动 | 客户端 | 121\.买卖股票              | 2  |
| 字节跳动 | 客户端 | 190\. 颠倒二进制位           | 2  |
| 字节跳动 | 客户端 | 199\. 二叉树的右视图          | 2  |
| 字节跳动 | 客户端 | 460\. LFU缓存            | 2  |
| 字节跳动 | 客户端 | 41\. 缺失的第一个正数          | 2  |
| 字节跳动 | 客户端 | 103\. [二叉树的锯齿形层次遍历](#103)      | 2  |
| 字节跳动 | 客户端 | 300\. 最长上升子序列          | 2  |
| 字节跳动 | 客户端 | 70\. 爬楼梯               | 2  |
| 字节跳动 | 客户端 | 54\. 螺旋矩阵              | 2  |
| 字节跳动 | 客户端 | 62\. 不同路径              | 2  |
| 字节跳动 | 客户端 | 189\. 旋转数组             | 2  |
| 字节跳动 | 客户端 | 48\. 旋转图像              | 2  |
| 字节跳动 | 客户端 | 剑指 Offer 27\. 二叉树的镜像   | 2  |
| 字节跳动 | 客户端 | 113\. 路径总和 II          | 2  |
| 字节跳动 | 后端 | 25\. K 个一组翻转链表          | 9  |
| 字节跳动 | 后端 | 3\. 无重复字符的最长子串          | 8  |
| 字节跳动 | 后端 | 102\. 二叉树的层序遍历          | 6  |
| 字节跳动 | 后端 | 124\. 二叉树中的最大路径和        | 6  |
| 字节跳动 | 后端 | 206\. 反转链表              | 6  |
| 字节跳动 | 后端 | 15\. 三数之和               | 6  |
| 字节跳动 | 后端 | 146\. LRU缓存机制           | 6  |
| 字节跳动 | 后端 | 215\. 数组中的第K个最大元素       | 5  |
| 字节跳动 | 后端 | 2\. 两数相加                | 5  |
| 字节跳动 | 后端 | 141\. 环形链表              | 5  |
| 字节跳动 | 后端 | 234\. 回文链表              | 5  |
| 字节跳动 | 后端 | 155\. 最小栈               | 4  |
| 字节跳动 | 后端 | 105\. 从前序与中序遍历序列构造二叉树   | 4  |
| 字节跳动 | 后端 | 33\. 搜索旋转排序数组           | 4  |
| 字节跳动 | 后端 | 160\. 相交链表              | 4  |
| 字节跳动 | 后端 | 128\. 最长连续序列            | 4  |
| 字节跳动 | 后端 | 103\. [二叉树的锯齿形层次遍历](#103)       | 4  |
| 字节跳动 | 后端 | 113\. 路径总和 II           | 4  |
| 字节跳动 | 后端 | 121\.买卖股票               | 3  |
| 字节跳动 | 后端 | 108\. 将有序数组转换为二叉搜索树     | 3  |
| 字节跳动 | 后端 | 199\.二叉树的右视图            | 3  |
| 字节跳动 | 后端 | 88\. 合并两个有序数组           | 3  |
| 字节跳动 | 后端 | 162\. 寻找峰值              | 3  |
| 字节跳动 | 后端 | 56\. 合并区间               | 3  |
| 字节跳动 | 后端 | 110\. 平衡二叉树             | 3  |
| 字节跳动 | 后端 | 236\. 二叉树的最近公共祖先        | 3  |
| 字节跳动 | 后端 | 322\. 零钱兑换              | 3  |
| 字节跳动 | 后端 | 101\. 对称二叉树             | 3  |
| 字节跳动 | 后端 | 199\. 二叉树的右视图           | 3  |
| 字节跳动 | 后端 | 20\. 有效的括号              | 3  |
| 字节跳动 | 后端 | 143\. 重排链表              | 3  |
| 字节跳动 | 后端 | 54\. 螺旋矩阵               | 2  |
| 字节跳动 | 后端 | 221\. 最大正方形             | 2  |
| 字节跳动 | 后端 | 23\. 合并K个排序链表           | 2  |
| 字节跳动 | 后端 | 83\. 删除排序链表中的重复元素       | 2  |
| 字节跳动 | 后端 | 70\. 爬楼梯                | 2  |
| 字节跳动 | 后端 | 剑指 Offer 61\. 扑克牌中的顺子   | 2  |
| 字节跳动 | 后端 | 32\. 最长有效括号             | 2  |
| 字节跳动 | 后端 | 剑指 Offer 42\. 连续子数组的最大和 | 2  |
| 字节跳动 | 后端 | 415\. 字符串相加             | 2  |
| 字节跳动 | 后端 | 41\. 缺失的第一个正数           | 2  |
| 字节跳动 | 后端 | 704\. 二分查找              | 2  |
| 字节跳动 | 后端 | 958\. 二叉树的完全性检验         | 2  |
| 字节跳动 | 后端 | 69\. x 的平方根             | 2  |
| 字节跳动 | 后端 | 114\. 二叉树展开为链表          | 2  |

<span id="103"></span>
[103\. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)
![](https://upload-images.jianshu.io/upload_images/19741117-53e114dff97413ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if (root == null)
            return new ArrayList();
        List<List<Integer>> result = new ArrayList<>();

        int flag = 0;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> path = new ArrayList();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();

                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);

                path.add(node.val);
            }

            if (flag % 2 == 1) {
                Collections.reverse(path);
            }
            flag++;
            if (path.size() != 0) {
                result.add(path);
            }
        }
        return result;
    }

```

