| 公司   | 岗位  | 题目                     | 次数 |
|------|-----|------------------------|----|
| 字节跳动 | 客户端 | [53\. 最大子序和](#53)             | 7  |
| 字节跳动 | 客户端 | [215\. 数组中的第K个最大元素](#215)      | 6  |
| 字节跳动 | 客户端 | [236\. 二叉树的最近公共祖先](#236)       | 6  |
| 字节跳动 | 客户端 | [206\. 反转链表](#206)             | 6  |
| 字节跳动 | 客户端 | [21\. 合并两个有序链表](#21)          | 6  |
| 字节跳动 | 客户端 | [25\. K 个一组翻转链表](#25)         | 5  |
| 字节跳动 | 客户端 | [09\. 用两个栈实现队列](#09) | 5  |
| 字节跳动 | 客户端 | [146\. LRU缓存机制](#146)          | 5  |
| 字节跳动 | 客户端 | [144\. 二叉树的前序遍历](#144)         | 4  |
| 字节跳动 | 客户端 | [344\. 反转字符串](#344)            | 4  |
| 字节跳动 | 客户端 | [543\. 二叉树的直径](#543)           | 4  |
| 字节跳动 | 客户端 | [160\. 相交链表](160)             | 4  |
| 字节跳动 | 客户端 | [142\. 环形链表 II](#142)          | 3  |
| 字节跳动 | 客户端 | [104\. 二叉树的最大深度](#104)         | 3  |
| 字节跳动 | 客户端 | [394\. 字符串解码](#394)            | 3  |
| 字节跳动 | 客户端 | [145\. 二叉树的后序遍历](#145)         | 3  |
| 字节跳动 | 客户端 | [102\. 二叉树的层序遍历](#102)         | 3  |
| 字节跳动 | 客户端 | [3\. 无重复字符的最长子串](#3)         | 3  |
| 字节跳动 | 客户端 | [151\. 翻转字符串里的单词](#151)        | 3  |
| 字节跳动 | 客户端 | [958\. 二叉树的完全性检验](#958)        | 3  |
| 字节跳动 | 客户端 | [1\. 两数之和](#1)               | 3  |
| 字节跳动 | 客户端 | [94\. 二叉树的中序遍历](#94)          | 2  |
| 字节跳动 | 客户端 | [240\. 搜索二维矩阵 II](#240)        | 2  |
| 字节跳动 | 客户端 | [33\. 搜索旋转排序数组](#33)          | 2  |
| 字节跳动 | 客户端 | [121\.买卖股票](#121)              | 2  |
| 字节跳动 | 客户端 | [190\. 颠倒二进制位](#190)           | 2  |
| 字节跳动 | 客户端 | [199\. 二叉树的右视图](#199)          | 2  |
| 字节跳动 | 客户端 | [460\. LFU缓存](#460)            | 2  |
| 字节跳动 | 客户端 | [41\. 缺失的第一个正数](#41)          | 2  |
| 字节跳动 | 客户端 | [103\. 二叉树的锯齿形层次遍历](#103)      | 2  |
| 字节跳动 | 客户端 | [300\. 最长上升子序列](#300)          | 2  |
| 字节跳动 | 客户端 | [70\. 爬楼梯](#70)               | 2  |
| 字节跳动 | 客户端 | [54\. 螺旋矩阵](#54)              | 2  |
| 字节跳动 | 客户端 | [62\. 不同路径](#62)              | 2  |
| 字节跳动 | 客户端 | [189\. 旋转数组](#189)             | 2  |
| 字节跳动 | 客户端 | [48\. 旋转图像](#48)              | 2  |
| 字节跳动 | 客户端 | [27\. 二叉树的镜像](#27)   | 2  |
| 字节跳动 | 客户端 | [113\. 路径总和 II](#113)          | 2  |
| 字节跳动 | 后端 | 25\. K 个一组翻转链表         | 9  |
| 字节跳动 | 后端 | 3\. 无重复字符的最长子串          | 8  |
| 字节跳动 | 后端 | 102\. 二叉树的层序遍历          | 6  |
| 字节跳动 | 后端 | 124\. 二叉树中的最大路径和        | 6  |
| 字节跳动 | 后端 | 206\. 反转链表              | 6  |
| 字节跳动 | 后端 | 15\. 三数之和               | 6  |
| 字节跳动 | 后端 | 146\. LRU缓存机制           | 6  |
| 字节跳动 | 后端 | [215\. 数组中的第K个最大元素](#215)       | 5  |
| 字节跳动 | 后端 | 2\. 两数相加                | 5  |
| 字节跳动 | 后端 | 141\. 环形链表              | 5  |
| 字节跳动 | 后端 | 234\. 回文链表              | 5  |
| 字节跳动 | 后端 | 155\. 最小栈               | 4  |
| 字节跳动 | 后端 | 105\. 从前序与中序遍历序列构造二叉树   | 4  |
| 字节跳动 | 后端 | 33\. 搜索旋转排序数组           | 4  |
| 字节跳动 | 后端 | 160\. 相交链表              | 4  |
| 字节跳动 | 后端 | 128\. 最长连续序列            | 4  |
| 字节跳动 | 后端 | 103\. [二叉树的锯齿形层次遍历](#103)       | 4  |
| 字节跳动 | 后端 | 113\. 路径总和 II           | 4  |
| 字节跳动 | 后端 | 121\.买卖股票               | 3  |
| 字节跳动 | 后端 | 108\. 将有序数组转换为二叉搜索树     | 3  |
| 字节跳动 | 后端 | 199\.二叉树的右视图            | 3  |
| 字节跳动 | 后端 | 88\. 合并两个有序数组           | 3  |
| 字节跳动 | 后端 | 162\. 寻找峰值              | 3  |
| 字节跳动 | 后端 | 56\. 合并区间               | 3  |
| 字节跳动 | 后端 | 110\. 平衡二叉树             | 3  |
| 字节跳动 | 后端 | 236\. 二叉树的最近公共祖先        | 3  |
| 字节跳动 | 后端 | 322\. 零钱兑换              | 3  |
| 字节跳动 | 后端 | 101\. 对称二叉树             | 3  |
| 字节跳动 | 后端 | 199\. 二叉树的右视图           | 3  |
| 字节跳动 | 后端 | 20\. 有效的括号              | 3  |
| 字节跳动 | 后端 | 143\. 重排链表              | 3  |
| 字节跳动 | 后端 | 54\. 螺旋矩阵               | 2  |
| 字节跳动 | 后端 | 221\. 最大正方形             | 2  |
| 字节跳动 | 后端 | 23\. 合并K个排序链表           | 2  |
| 字节跳动 | 后端 | 83\. 删除排序链表中的重复元素       | 2  |
| 字节跳动 | 后端 | 70\. 爬楼梯                | 2  |
| 字节跳动 | 后端 | 剑指 Offer 61\. 扑克牌中的顺子   | 2  |
| 字节跳动 | 后端 | 32\. 最长有效括号             | 2  |
| 字节跳动 | 后端 | 剑指 Offer 42\. 连续子数组的最大和 | 2  |
| 字节跳动 | 后端 | 415\. 字符串相加             | 2  |
| 字节跳动 | 后端 | 41\. 缺失的第一个正数           | 2  |
| 字节跳动 | 后端 | 704\. 二分查找              | 2  |
| 字节跳动 | 后端 | 958\. 二叉树的完全性检验         | 2  |
| 字节跳动 | 后端 | 69\. x 的平方根             | 2  |
| 字节跳动 | 后端 | 114\. 二叉树展开为链表          | 2  |
<span id="0"></span>

<span id="236"></span>
[236\. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
![](https://upload-images.jianshu.io/upload_images/19741117-1fdd066e8880883c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == p || root == q || root == null )
            return root;
        TreeNode leftResult = lowestCommonAncestor(root.left,p,q);
        TreeNode rightResult = lowestCommonAncestor(root.right,p,q);
        return leftResult==null ? rightResult :rightResult==null?leftResult:root; 
    }
```

<span id="215"></span>
[215\. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
![](https://upload-images.jianshu.io/upload_images/19741117-752836850a1dfd25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
    public int findKthLargest(int[] nums, int k) {
        if (nums == null)
            return 0;
        PriorityQueue<Integer> queue = new PriorityQueue<>(k);
        for (int ele : nums) {
            if (queue.size() < k) {
                queue.add(ele);
                continue;
            }
            if (queue.peek() < ele) {
                queue.poll();
                queue.add(ele);
            }
        }
        return queue.peek();
    }

```

<span id="53"></span>
[53\. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/). 
![](https://upload-images.jianshu.io/upload_images/19741117-e48ff5e7c75bf2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```

    public int maxSubArray(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        // dp[i] --> 以 i 结尾的最大长度
        int[] dp = new int[nums.length];
        int maxValue;
        dp[0] = maxValue = nums[0];

        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);
            if (dp[i] > maxValue) {
                maxValue = dp[i];
            }
        }
        return maxValue;
    }

```


<span id="103"></span>
[103\. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)
![](https://upload-images.jianshu.io/upload_images/19741117-53e114dff97413ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if (root == null)
            return new ArrayList();
        List<List<Integer>> result = new ArrayList<>();

        int flag = 0;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> path = new ArrayList();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();

                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);

                path.add(node.val);
            }

            if (flag % 2 == 1) {
                Collections.reverse(path);
            }
            flag++;
            if (path.size() != 0) {
                result.add(path);
            }
        }
        return result;
    }

```

