
![](https://upload-images.jianshu.io/upload_images/19741117-8ec94c4688cea875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

| 题目                     | 次数 |
|------------------------|----|
| [53\. 最大子序和](#53)             | 7  |
| [215\. 数组中的第K个最大元素](#215)      | 6  |
| [236\. 二叉树的最近公共祖先](#236)       | 6  |
| [206\. 反转链表](#206)             | 6  |
| [21\. 合并两个有序链表](#21)          | 6  |
| [25\. K 个一组翻转链表](#25)         | 5  |
| [09\. 用两个栈实现队列](#09) | 5  |
| [146\. LRU缓存机制](#146)          | 5  |
| [144\. 二叉树的前序遍历](#144)         | 4  |
| [344\. 反转字符串](#344)            | 4  |
| [543\. 二叉树的直径](#543)           | 4  |
| [160\. 相交链表](160)             | 4  |
| [142\. 环形链表 II](#142)          | 3  |
| [104\. 二叉树的最大深度](#104)         | 3  |
| [394\. 字符串解码](#394)            | 3  |
| [145\. 二叉树的后序遍历](#145)         | 3  |
| [102\. 二叉树的层序遍历](#102)         | 3  |
| [3\. 无重复字符的最长子串](#3)         | 3  |
| [151\. 翻转字符串里的单词](#151)        | 3  |
| [958\. 二叉树的完全性检验](#958)        | 3  |
| [1\. 两数之和](#1)               | 3  |
| [94\. 二叉树的中序遍历](#94)          | 2  |
| [240\. 搜索二维矩阵 II](#240)        | 2  |
| [33\. 搜索旋转排序数组](#33)          | 2  |
| [121\.买卖股票](#121)              | 2  |
| [190\. 颠倒二进制位](#190)           | 2  |
| [199\. 二叉树的右视图](#199)          | 2  |
| [460\. LFU缓存](#460)            | 2  |
| [41\. 缺失的第一个正数](#41)          | 2  |
| [103\. 二叉树的锯齿形层次遍历](#103)      | 2  |
| [300\. 最长上升子序列](#300)          | 2  |
| [70\. 爬楼梯](#70)               | 2  |
| [54\. 螺旋矩阵](#54)              | 2  |
| [62\. 不同路径](#62)              | 2  |
| [189\. 旋转数组](#189)             | 2  |
| [48\. 旋转图像](#48)              | 2  |
| [27\. 二叉树的镜像](#27)   | 2  |
| [113\. 路径总和 II](#113)          | 2  |
| 25\. K 个一组翻转链表         | 9  |
| 3\. 无重复字符的最长子串          | 8  |
| 102\. 二叉树的层序遍历          | 6  |
| 124\. 二叉树中的最大路径和        | 6  |
| 206\. 反转链表              | 6  |
| 15\. 三数之和               | 6  |
| 146\. LRU缓存机制           | 6  |
| [215\. 数组中的第K个最大元素](#215)       | 5  |
| 2\. 两数相加                | 5  |
| 141\. 环形链表              | 5  |
| 234\. 回文链表              | 5  |
| 155\. 最小栈               | 4  |
| 105\. 从前序与中序遍历序列构造二叉树   | 4  |
| 33\. 搜索旋转排序数组           | 4  |
| 160\. 相交链表              | 4  |
| 128\. 最长连续序列            | 4  |
| 103\. [二叉树的锯齿形层次遍历](#103)       | 4  |
| 113\. 路径总和 II           | 4  |
| 121\.买卖股票               | 3  |
| 108\. 将有序数组转换为二叉搜索树     | 3  |
| 199\.二叉树的右视图            | 3  |
| 88\. 合并两个有序数组           | 3  |
| 162\. 寻找峰值              | 3  |
| 56\. 合并区间               | 3  |
| 110\. 平衡二叉树             | 3  |
| 236\. 二叉树的最近公共祖先        | 3  |
| 322\. 零钱兑换              | 3  |
| 101\. 对称二叉树             | 3  |
| 199\. 二叉树的右视图           | 3  |
| 20\. 有效的括号              | 3  |
| 143\. 重排链表              | 3  |
| 54\. 螺旋矩阵               | 2  |
| 221\. 最大正方形             | 2  |
| 23\. 合并K个排序链表           | 2  |
| 83\. 删除排序链表中的重复元素       | 2  |
| 70\. 爬楼梯                | 2  |
| 剑指 Offer 61\. 扑克牌中的顺子   | 2  |
| 32\. 最长有效括号             | 2  |
| 剑指 Offer 42\. 连续子数组的最大和 | 2  |
| 415\. 字符串相加             | 2  |
| 41\. 缺失的第一个正数           | 2  |
| 704\. 二分查找              | 2  |
| 958\. 二叉树的完全性检验         | 2  |
| 69\. x 的平方根             | 2  |
| 114\. 二叉树展开为链表          | 2  |
<span id="0"></span>

<span id="21"></span>
[21\. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
![](https://upload-images.jianshu.io/upload_images/19741117-18ed4f80b7294954.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```

    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }

```

<span id="206"></span>
[206\. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
![](https://upload-images.jianshu.io/upload_images/19741117-247c154620986642.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```

    public ListNode reverseList(ListNode head) {
        if (head == null)
            return head;
        ListNode dummyNode = new ListNode(-1);
        while (head != null) {
            ListNode next = head.next;
            head.next = dummyNode.next;
            dummyNode.next = head;
            head = next;
        }
        return dummyNode.next;
    }

```

<span id="236"></span>
[236\. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
![](https://upload-images.jianshu.io/upload_images/19741117-1fdd066e8880883c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == p || root == q || root == null )
            return root;
        TreeNode leftResult = lowestCommonAncestor(root.left,p,q);
        TreeNode rightResult = lowestCommonAncestor(root.right,p,q);
        return leftResult==null ? rightResult :rightResult==null?leftResult:root; 
    }
```

<span id="215"></span>
[215\. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
![](https://upload-images.jianshu.io/upload_images/19741117-752836850a1dfd25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
    public int findKthLargest(int[] nums, int k) {
        if (nums == null)
            return 0;
        PriorityQueue<Integer> queue = new PriorityQueue<>(k);
        for (int ele : nums) {
            if (queue.size() < k) {
                queue.add(ele);
                continue;
            }
            if (queue.peek() < ele) {
                queue.poll();
                queue.add(ele);
            }
        }
        return queue.peek();
    }

```

<span id="53"></span>
[53\. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/). 
![](https://upload-images.jianshu.io/upload_images/19741117-e48ff5e7c75bf2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```

    public int maxSubArray(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        // dp[i] --> 以 i 结尾的最大长度
        int[] dp = new int[nums.length];
        int maxValue;
        dp[0] = maxValue = nums[0];

        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);
            if (dp[i] > maxValue) {
                maxValue = dp[i];
            }
        }
        return maxValue;
    }

```


<span id="103"></span>
[103\. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)
![](https://upload-images.jianshu.io/upload_images/19741117-53e114dff97413ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if (root == null)
            return new ArrayList();
        List<List<Integer>> result = new ArrayList<>();

        int flag = 0;
        Deque<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> path = new ArrayList();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();

                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);

                path.add(node.val);
            }

            if (flag % 2 == 1) {
                Collections.reverse(path);
            }
            flag++;
            if (path.size() != 0) {
                result.add(path);
            }
        }
        return result;
    }

```

